| Sorting Algorithm | Mechanism/Working                                                                                                                                   | Time Complexity                                                            | Space Complexity | Common Uses/Applications                                                                                     |
|-------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------|------------------|--------------------------------------------------------------------------------------------------------------|
| **Bubble Sort**   | Repeatedly compares and swaps adjacent elements until the list is sorted.                                                                          | Worst-case: O(n²); Best-case: O(n) (when nearly sorted)                      | O(1)             | Educational purposes, simple implementation, small or nearly sorted arrays.                                  |
| **Selection Sort**| Repeatedly selects the minimum (or maximum) element from the unsorted portion and moves it to the sorted portion.                                   | O(n²) in all cases                                                         | O(1)             | Small datasets, scenarios where memory writes are costly compared to comparisons.                           |
| **Insertion Sort**| Builds the sorted array one element at a time by inserting each new element into its proper position within the sorted portion.                      | Worst-case: O(n²); Best-case: O(n) (if already sorted)                       | O(1)             | Nearly sorted arrays, small datasets, online sorting where data continuously arrives.                        |
| **Merge Sort**    | Uses divide and conquer: recursively splits the array into halves, sorts each half, and then merges the sorted halves back together.               | O(n log n) in all cases                                                     | O(n)             | Stable sorting, external sorting, sorting linked lists, and when predictable performance is required.         |
| **Quick Sort**    | Partitions the array around a pivot element, then recursively sorts the subarrays on either side of the pivot.                                      | Average-case: O(n log n); Worst-case: O(n²) (rare with good pivot selection) | O(log n) average (recursion stack), O(n) worst-case | General-purpose sorting, in-place sorting, widely used due to excellent average-case performance.            |
| **Heap Sort**     | Converts the array into a heap data structure, then repeatedly extracts the maximum (or minimum) element to build the sorted array.                 | O(n log n) in all cases                                                     | O(1)             | In-place sorting, situations where worst-case performance guarantees are needed, and priority queue implementations. |
| **Counting Sort** | Counts the occurrences of each distinct element, then calculates positions for each element to construct the sorted output.                         | O(n + k), where k is the range of input values                              | O(n + k)         | Non-comparison sorting for integers or objects with a limited range, such as age or grade distributions.       |
| **Radix Sort**    | Processes each digit of the numbers (or characters of keys) using a stable sort (often Counting Sort) as a subroutine, sorting by each digit from LSD to MSD. | O(d*(n + k)) where d is the number of digits; effectively O(n) when d is constant | O(n + k)         | Sorting large sets of numbers or strings with fixed length keys, when traditional O(n log n) sorts may be slower. |
| **Bucket Sort**   | Distributes elements into a number of buckets, sorts each bucket individually (often with Insertion Sort), and then concatenates them.               | Average-case: O(n + k); Worst-case: O(n²) if buckets are unevenly distributed | O(n)             | Uniformly distributed data, such as floating-point numbers in the range [0,1), and data that can be efficiently bucketed. |
| **Shell Sort**    | An optimization of Insertion Sort that allows the exchange of distant elements by sorting elements at a specific gap, which decreases over time.      | Depends on gap sequence; average between O(n^(3/2)) to O(n^(4/3))           | O(1)             | In-place sorting with better performance than Insertion Sort for medium-sized arrays, though not stable.         |